const DynamicProcessor = global.utils.DynamicProcessor();

/**
 * Processor declaration generator
 */
module.exports = class extends DynamicProcessor {
    get dp() {
        return 'packager.declaration';
    }

    #packager;
    get packager() {
        return this.#packager;
    }

    get id() {
        return this.#packager.processor.id;
    }

    get hash() {
        return this.#packager.processor.hash;
    }

    get compiler() {
        return this.#packager.compiler;
    }

    #diagnostics;
    get diagnostics() {
        this.#process();
        return this.#diagnostics;
    }

    get valid() {
        this.#process();
        return this.#diagnostics.valid;
    }

    constructor(packager) {
        super();
        this.#packager = packager;

        // The txt bundle depends on the js code to generate the declaration.
        // The ts bundle, on the other hand, uses the declarations of the source files generated by the compiler.
        // As the dp (dynamic processor) that generates the code has the compiler as a child,
        // configuring the code dp works for both cases.
        super.setup(new Map([['code', {child: packager.js}]]));
    }

    _build() {
        throw new Error('Method must be overridden');
    }

    #processed = false;

    #process() {
        if (this.#processed) return;

        if (!this.compiler.valid) {
            this.#diagnostics = this.compiler.diagnostics;
            return;
        }

        const diagnostics = this.#diagnostics = new (require('./diagnostics'))();
        this.#code = this._build(diagnostics);
        this.#processed = true;
    }

    #code;
    get code() {
        if (!this.#processed) this.#process();
        return this.#code;
    }

    _process() {
        this.#processed = false;
    }
}
